function unpackedFile = fn_BionodeBinOpen(packedFileDir, ADCres, sampR)
%% fn_BionodeBinOpen.m
%
% Created by: Alessandro Ascani Orsini
%
% Date: 11/09/2024
%
% Version: 0.0.2
%
% *Description*: This function opens a bin file generated by the Bionode, given the ADC resolution, sampling rate,
% header size, and outputs a struct containing all the data in the bin.

%% Unpack the rawdata
fileID = fopen(packedFileDir, 'rb'); % Get the file ID
if fileID == -1
    error('File could not be opened. Check the path or permissions.'); % Check if the file opened successfully
end

%% Read Timestamp Header (10 bytes) + Remaining Header Bytes
rawData = fread(fileID, 'uint8'); % Read the rawData data range between 0 to 255
%| Type     | Size              | Range   | What it reads                                                      |
%| -------- | ----------------- | ------- | ------------------------------------------------------------------ |
%| `uint8`  | 1 byte (8 bits)   | 0–255   | Reads **1 byte at a time** and treats it as a number               |
%| `uint16` | 2 bytes (16 bits) | 0–65535 | Reads **2 bytes at a time** and combines them into a single number |

year = bitshift(rawData(1), 8) + rawData(2);% shift 8 bit left equal to mul by 2^8 
month = rawData(3);
day = rawData(4);
hour = rawData(5);
minute = rawData(6);
second = rawData(7);
sampleRate = bitshift(rawData(8),8) + rawData(9);
numChannels = rawData(10);

% Store the timestamp as a datetime in the struct
unpackedFile.Date = datetime(year, month, day, hour, minute, second);
unpackedFile.sampleRate = sampleRate;
unpackedFile.numChannels = numChannels;

%% Initialize variables based on metadata
bytesPerSample = ADCres / 8; % Calculate the number of bytes per sample
dataFormat = ['bit', num2str(ADCres)]; % Data format string for fread, e.g., 'int16'

%% Data Packets
% the raw Data is divided in packets depending on the type. Small packets
% are 58 bytes, while long ones are 198 bytes.
% Each packet comes with the following structure:
% Sync = packet(1:2) 2 bytes
% PID = packet(3:4) 2 bytes
% TXID = packet(5) 1 byte
% RXID = packet(6) 1 byte
% packetType = packet(7) 1 byte

% packetData = packet(8:end-11) MAIN DATA

% StimStatus = packet(end-10:end-6) 5 bytes
% TimeStamp = packet(end-5:end-2) 4 bytes
% CRC = packet(end-1:end) 2 bytes

%% Extract Data packets (assume they are small)
packetNum = length(rawData)/58; % number of packets in the file
channelsData = zeros(numChannels,24*packetNum./numChannels); % preallocate channels data
nSamples = 24 / numChannels; % Determine number of samples per channel for the packet
PIDs = zeros(1, packetNum-1); % assuming first packet is header
fprintf("Unpacking Data from file... \n");

for i =2:packetNum
    tempPacket = rawData((58.*(i-1))+1:58.*(i));% create a temporary variable to store the packet
    PIDs(i-1) = bitshift(tempPacket(3), 8) + tempPacket(4);  % PID is bytes 3–4
    X = tempPacket(8:end-15); % this is the raw data. We need to convert it to Y and then Z according to packet manager.
    X_matrix = reshape(X, 3, []).'; % Reshape X into a matrix with 3 columns: each row contains 3 bytes
    yarr = uint32(X_matrix(:,1)) * 2^16 + uint32(X_matrix(:,2)) * 2^8 + uint32(X_matrix(:,3)); % Extract 24-bit values from combining 8-bit values in x
    % Extract 12-bit values from each 24-bit value in y
    zarr = zeros(1, 2*length(yarr));  % preallocate
    for j = 1:length(yarr)
        mask = 0xFFF000;
        for k = 1:2
            zarr(2*(j-1) + k) = bitshift(bitand(yarr(j), mask), -(12 * (2 - k)));
            mask = bitshift(mask, -12);
        end
    end

    % Distribute values across channels
    packetData = reshape(zarr, numChannels, nSamples); % Reshape zarr into a matrix with numChannels rows.
    sampleStart = (i-2)*nSamples + 1; % Calculate the sample indices for the current packet.
    sampleEnd   = (i-2)*nSamples + nSamples;
    channelsData(:, sampleStart:sampleEnd) = packetData; % Assign the reshaped data into channelsData

    % Provide a progress update
    if mod(i,round(packetNum*0.05))==0
        fprintf('Progress: %.0f%%\n', (i / packetNum) * 100);
    end
end

fprintf("Unpacking Completed! \n")

unpackedFile.channelsData = channelsData;
unpackedFile.PID = PIDs;
nSamples   = size(channelsData,2);

%% Estimate packet loss and expected count using a loop
modulus   = 2^16-1;
glitch  = 2^15-1; % sometimes there is bit flip
% Fix bitflip glitch
for i = 2:numel(PIDs)
  if mod(PIDs(i) - PIDs(i-1), modulus) == glitch
    PIDs(i) = bitxor(PIDs(i), glitch);% flip the 15th bit back
  end
end
pid_delta = mod( diff(PIDs), modulus );      % all wrapped differences
expected  = 1 + sum(pid_delta);              % +1 for the very first packet
lost      = sum( pid_delta(pid_delta>1) - 1 );
packetRatio = (expected - lost) / expected;


% Store in output struct
unpackedFile.expectedPackets = expected;
unpackedFile.lostPackets     = lost;
unpackedFile.packetRatio     = packetRatio;
unpackedFile.time = (0:(nSamples-1))/sampR;  

% Close the file
fclose(fileID);

end